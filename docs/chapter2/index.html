<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 2: Zero-Copy Operations - Ultra-Fast Networking</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="../assets/css/chapter.css">
    <script src="../assets/js/tutorial.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <a href="../">ðŸš€ Ultra-Fast Networking</a>
                <span class="chapter-indicator">Chapter 2: Zero-Copy Operations</span>
            </div>
            <div class="nav-links">
                <a href="../chapter1/">Previous</a>
                <a href="../">Home</a>
                <a href="../chapter3/">Next Chapter</a>
            </div>
        </div>
    </nav>

    <div class="chapter-container">
        <aside class="chapter-sidebar">
            <div class="chapter-progress">
                <h3>Progress</h3>
                <div class="progress-bar">
                    <div class="progress-fill" data-progress="0"></div>
                </div>
                <div class="progress-text">0% Complete</div>
            </div>
            
            <nav class="chapter-nav">
                <h3>Contents</h3>
                <ul>
                    <li><a href="#introduction" data-step="1">Understanding Zero-Copy</a></li>
                    <li><a href="#problem" data-step="2">Memory Copy Bottleneck</a></li>
                    <li><a href="#mmap-test" data-step="3">Write mmap Test</a></li>
                    <li><a href="#mmap-implement" data-step="4">Implement Memory Mapping</a></li>
                    <li><a href="#sendfile-test" data-step="5">Write sendfile Test</a></li>
                    <li><a href="#sendfile-implement" data-step="6">Implement sendfile</a></li>
                    <li><a href="#splice-test" data-step="7">Write splice Test</a></li>
                    <li><a href="#splice-implement" data-step="8">Implement splice</a></li>
                    <li><a href="#benchmark" data-step="9">Performance Comparison</a></li>
                    <li><a href="#wrap-up" data-step="10">Chapter Summary</a></li>
                </ul>
            </nav>

            <div class="learning-objectives">
                <h3>Learning Objectives</h3>
                <ul>
                    <li>Understand zero-copy concepts</li>
                    <li>Master mmap() for memory mapping</li>
                    <li>Implement sendfile() for file transfers</li>
                    <li>Use splice() for pipe operations</li>
                    <li>Measure performance improvements</li>
                </ul>
            </div>
        </aside>

        <main class="chapter-content">
            <div class="chapter-header">
                <h1>Chapter 2: Zero-Copy Operations</h1>
                <p class="chapter-subtitle">
                    Eliminate memory copies to achieve 50%+ performance improvements using Linux zero-copy syscalls.
                </p>
            </div>

            <section id="introduction" class="content-section" data-step="1">
                <h2>Understanding Zero-Copy</h2>
                <p>
                    Traditional networking involves multiple memory copies: from kernel to user space, 
                    then back to kernel space for transmission. Zero-copy eliminates these unnecessary copies.
                </p>

                <div class="concept-diagram">
                    <h4>Traditional Copy vs Zero-Copy</h4>
                    <div class="diagram-container">
                        <div class="copy-comparison">
                            <div class="traditional-copy">
                                <h5>Traditional (4 copies)</h5>
                                <div class="copy-flow">
                                    Disk â†’ Kernel â†’ User â†’ Kernel â†’ Network
                                </div>
                            </div>
                            <div class="zero-copy">
                                <h5>Zero-Copy (0 copies)</h5>
                                <div class="copy-flow">
                                    Disk â†’ Network (direct)
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <p>
                    Linux provides several zero-copy mechanisms:
                </p>
                <ul>
                    <li><strong>mmap()</strong> - Memory mapping files</li>
                    <li><strong>sendfile()</strong> - Direct file-to-socket transfer</li>
                    <li><strong>splice()</strong> - Pipe-based zero-copy</li>
                </ul>
            </section>

            <section id="problem" class="content-section" data-step="2">
                <h2>The Memory Copy Bottleneck</h2>
                <p>
                    Let's first measure the performance impact of memory copies by creating a test 
                    that demonstrates the problem.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy_test.go - Measuring copy overhead</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func TestMemoryCopyOverhead(t *testing.T) {
    // Create test data - 1MB
    dataSize := 1024 * 1024
    testData := make([]byte, dataSize)
    for i := range testData {
        testData[i] = byte(i % 256)
    }

    // Measure traditional copy approach
    iterations := 1000
    
    start := time.Now()
    for i := 0; i < iterations; i++ {
        // Simulate user-space copy
        buffer := make([]byte, len(testData))
        copy(buffer, testData)
        
        // Simulate processing (checksum)
        var sum uint64
        for _, b := range buffer {
            sum += uint64(b)
        }
    }
    traditionalTime := time.Since(start)

    t.Logf("Traditional copy: %v for %d iterations", 
        traditionalTime, iterations)
    t.Logf("Average per operation: %v", 
        traditionalTime/time.Duration(iterations))
    
    // This shows the baseline we need to improve
    assert.True(t, traditionalTime > 0)
}</code></pre>
                </div>

                <div class="test-runner">
                    <button class="demo-button" onclick="runTest('TestMemoryCopyOverhead')">
                        Run Test
                    </button>
                </div>

                <div class="terminal">
                    <div class="terminal-header">
                        <div class="terminal-dots">
                            <div class="terminal-dot red"></div>
                            <div class="terminal-dot yellow"></div>
                            <div class="terminal-dot green"></div>
                        </div>
                        <div class="terminal-title">Test Output</div>
                    </div>
                    <div class="terminal-content">
                        <pre><code>$ go test -v -run TestMemoryCopyOverhead
Click "Run Test" to see results...</code></pre>
                    </div>
                </div>
            </section>

            <section id="mmap-test" class="content-section" data-step="3">
                <h2>Write mmap Test First (Red)</h2>
                <p>
                    Following TDD, let's write a test for memory-mapped I/O before implementing it.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy_test.go - mmap test</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func TestZeroCopyMmap(t *testing.T) {
    // Create zero-copy socket
    zcSocket, err := NewZeroCopySocket()
    if err != nil {
        t.Fatalf("Failed to create zero-copy socket: %v", err)
    }
    defer zcSocket.Close()

    // Test data
    testData := []byte("Hello, Zero-Copy World!")
    
    // Send using memory-mapped buffer
    n, err := zcSocket.SendMmapped(testData, "127.0.0.1", 12345)
    assert.NoError(t, err)
    assert.Equal(t, len(testData), n)

    // Verify mmap buffer is allocated
    buffer := zcSocket.GetMmapBuffer()
    assert.NotNil(t, buffer)
    assert.True(t, len(buffer) > 0)
    
    // Verify data was written to mmap buffer
    assert.Equal(t, testData, buffer[:len(testData)])
}</code></pre>
                </div>

                <div class="knowledge-check">
                    <h4>ðŸ§  Knowledge Check</h4>
                    <ul>
                        <li>
                            <input type="checkbox" id="kc1"> 
                            <label for="kc1">I understand what mmap() does</label>
                        </li>
                        <li>
                            <input type="checkbox" id="kc2"> 
                            <label for="kc2">I can explain why zero-copy is faster</label>
                        </li>
                        <li>
                            <input type="checkbox" id="kc3"> 
                            <label for="kc3">I wrote the test before implementation</label>
                        </li>
                    </ul>
                </div>
            </section>

            <section id="mmap-implement" class="content-section" data-step="4">
                <h2>Make mmap Test Pass (Green)</h2>
                <p>
                    Now let's implement the memory mapping functionality to make our test pass.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy.go - mmap implementation</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">// initMmapBuffer creates a memory-mapped buffer for zero-copy operations
func (zcs *ZeroCopySocket) initMmapBuffer() error {
    // Create anonymous memory mapping
    mmapBuffer, err := syscall.Mmap(-1, 0, zcs.bufferSize,
        syscall.PROT_READ|syscall.PROT_WRITE,
        syscall.MAP_PRIVATE|syscall.MAP_ANONYMOUS)
    if err != nil {
        return fmt.Errorf("mmap failed: %v", err)
    }

    zcs.mmapBuffer = mmapBuffer
    return nil
}

// SendMmapped sends data using memory-mapped I/O
func (zcs *ZeroCopySocket) SendMmapped(data []byte, destIP string, destPort uint16) (int, error) {
    if len(data) > len(zcs.mmapBuffer) {
        return 0, fmt.Errorf("data size %d exceeds mmap buffer size %d", 
            len(data), len(zcs.mmapBuffer))
    }

    // Copy data to memory-mapped buffer
    // In production, applications would write directly to mmap buffer
    copy(zcs.mmapBuffer, data)

    // Send using the memory-mapped buffer
    return zcs.SendTo(zcs.mmapBuffer[:len(data)], destIP, destPort)
}</code></pre>
                </div>

                <div class="test-runner">
                    <button class="demo-button" onclick="runTest('TestZeroCopyMmap')">
                        Run mmap Test
                    </button>
                </div>
            </section>

            <section id="sendfile-test" class="content-section" data-step="5">
                <h2>Write sendfile Test (Red)</h2>
                <p>
                    The sendfile() syscall enables direct file-to-socket transfer without copying 
                    data through user space.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy_test.go - sendfile test</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func TestZeroCopySendfile(t *testing.T) {
    // Create test file
    testFile := "/tmp/zerocopy_test.txt"
    testContent := strings.Repeat("Zero-copy file transfer test\n", 1000)
    err := os.WriteFile(testFile, []byte(testContent), 0644)
    assert.NoError(t, err)
    defer os.Remove(testFile)

    // Create zero-copy socket
    zcSocket, err := NewZeroCopySocket()
    if err != nil {
        t.Fatalf("Failed to create zero-copy socket: %v", err)
    }
    defer zcSocket.Close()

    // Test sendfile transfer
    bytesSent, err := zcSocket.SendFile(testFile, "127.0.0.1", 12346)
    assert.NoError(t, err)
    assert.Equal(t, int64(len(testContent)), bytesSent)

    t.Logf("Sent %d bytes using sendfile", bytesSent)
}</code></pre>
                </div>
            </section>

            <section id="sendfile-implement" class="content-section" data-step="6">
                <h2>Implement sendfile (Green)</h2>
                <p>
                    Let's implement the sendfile functionality. Note that sendfile works with TCP,
                    so we'll create a TCP connection for demonstration.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy.go - sendfile implementation</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">// SendFile sends a file using zero-copy sendfile() syscall
func (zcs *ZeroCopySocket) SendFile(filePath string, destIP string, destPort uint16) (int64, error) {
    // Open the file
    file, err := os.Open(filePath)
    if err != nil {
        return 0, fmt.Errorf("failed to open file: %v", err)
    }
    defer file.Close()

    // Get file size
    fileInfo, err := file.Stat()
    if err != nil {
        return 0, fmt.Errorf("failed to get file info: %v", err)
    }
    fileSize := fileInfo.Size()

    // Create TCP socket for sendfile (UDP doesn't support sendfile)
    tcpFd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0)
    if err != nil {
        return 0, fmt.Errorf("failed to create TCP socket: %v", err)
    }
    defer syscall.Close(tcpFd)

    // Parse destination address
    ipBytes := parseIPv4(destIP)
    if ipBytes == nil {
        return 0, fmt.Errorf("invalid IP address: %s", destIP)
    }

    destAddr := &syscall.SockaddrInet4{
        Port: int(destPort),
        Addr: [4]byte{ipBytes[0], ipBytes[1], ipBytes[2], ipBytes[3]},
    }

    // Try to connect - if it fails, simulate zero-copy for UDP
    if err := syscall.Connect(tcpFd, destAddr); err != nil {
        return zcs.simulateZeroCopyFileSend(file, fileSize, destIP, destPort)
    }

    // Use sendfile for true zero-copy transfer
    n, err := syscall.Sendfile(tcpFd, int(file.Fd()), nil, int(fileSize))
    return int64(n), err
}</code></pre>
                </div>
            </section>

            <section id="splice-test" class="content-section" data-step="7">
                <h2>Write splice Test (Red)</h2>
                <p>
                    The splice() syscall moves data between file descriptors without copying to user space.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy_test.go - splice test</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func TestZeroCopySplice(t *testing.T) {
    // Create zero-copy socket
    zcSocket, err := NewZeroCopySocket()
    if err != nil {
        t.Fatalf("Failed to create zero-copy socket: %v", err)
    }
    defer zcSocket.Close()

    // Create test file
    testFile := "/tmp/splice_test.txt"
    testContent := "Splice zero-copy test data"
    err = os.WriteFile(testFile, []byte(testContent), 0644)
    assert.NoError(t, err)
    defer os.Remove(testFile)

    // Open input file
    inputFile, err := os.Open(testFile)
    assert.NoError(t, err)
    defer inputFile.Close()

    // Create output pipe
    outputFile, err := os.Create("/tmp/splice_output.txt")
    assert.NoError(t, err)
    defer outputFile.Close()
    defer os.Remove("/tmp/splice_output.txt")

    // Test splice operation
    bytesSpliced, err := zcSocket.Splice(int(inputFile.Fd()), 
        int(outputFile.Fd()), len(testContent))
    
    assert.NoError(t, err)
    assert.Equal(t, int64(len(testContent)), bytesSpliced)

    t.Logf("Spliced %d bytes", bytesSpliced)
}</code></pre>
                </div>
            </section>

            <section id="splice-implement" class="content-section" data-step="8">
                <h2>Implement splice (Green)</h2>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy.go - splice implementation</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">// Linux splice constants
const (
    SPLICE_F_MOVE = 0x01
    SPLICE_F_MORE = 0x04
)

// Splice performs zero-copy data transfer between file descriptors
func (zcs *ZeroCopySocket) Splice(inputFd int, outputFd int, length int) (int64, error) {
    // Create a pipe for splice operation
    pipeRead, pipeWrite, err := os.Pipe()
    if err != nil {
        return 0, fmt.Errorf("failed to create pipe: %v", err)
    }
    defer pipeRead.Close()
    defer pipeWrite.Close()

    // Splice from input to pipe
    n1, err := syscall.Splice(inputFd, nil, int(pipeWrite.Fd()), nil, length,
        SPLICE_F_MOVE|SPLICE_F_MORE)
    if err != nil {
        return 0, fmt.Errorf("splice input->pipe failed: %v", err)
    }

    // Splice from pipe to output
    n2, err := syscall.Splice(int(pipeRead.Fd()), nil, outputFd, nil, int(n1),
        SPLICE_F_MOVE)
    if err != nil {
        return n1, fmt.Errorf("splice pipe->output failed: %v", err)
    }

    return n2, nil
}</code></pre>
                </div>

                <div class="test-runner">
                    <button class="demo-button" onclick="runTest('TestZeroCopySplice')">
                        Run splice Test
                    </button>
                </div>
            </section>

            <section id="benchmark" class="content-section" data-step="9">
                <h2>Performance Benchmark</h2>
                <p>
                    Let's create a comprehensive benchmark to measure the performance improvements
                    of our zero-copy implementations.
                </p>

                <div class="code-editor">
                    <div class="code-header">
                        <div class="code-title">zerocopy_test.go - Performance benchmark</div>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func TestZeroCopyPerformance(t *testing.T) {
    zcSocket, err := NewZeroCopySocket()
    if err != nil {
        t.Fatalf("Failed to create zero-copy socket: %v", err)
    }
    defer zcSocket.Close()

    // Run performance benchmark
    results, err := zcSocket.PerformanceBenchmark(1024*1024, 1000) // 1MB, 1000 iterations
    assert.NoError(t, err)

    t.Logf("Performance Results:")
    t.Logf(results.String())

    // Verify improvement
    assert.True(t, results.ImprovementRatio > 1.0, 
        "Zero-copy should be faster than regular copy")
    
    if results.ImprovementRatio > 1.5 {
        t.Logf("ðŸš€ Excellent! %.2fx improvement", results.ImprovementRatio)
    }
}</code></pre>
                </div>

                <div class="demo-container">
                    <h4>Run Live Benchmark</h4>
                    <button class="demo-button" onclick="runBenchmark()">
                        Start Performance Test
                    </button>
                </div>

                <div class="terminal">
                    <div class="terminal-header">
                        <div class="terminal-dots">
                            <div class="terminal-dot red"></div>
                            <div class="terminal-dot yellow"></div>
                            <div class="terminal-dot green"></div>
                        </div>
                        <div class="terminal-title">Benchmark Results</div>
                    </div>
                    <div class="terminal-content">
                        <pre><code>Click "Start Performance Test" to see benchmark results...</code></pre>
                    </div>
                </div>
            </section>

            <section id="wrap-up" class="content-section" data-step="10">
                <h2>Chapter 2 Summary</h2>
                
                <div class="summary-box">
                    <h3>ðŸŽ¯ What You've Learned</h3>
                    <ul>
                        <li><strong>Zero-Copy Concepts</strong> - Eliminated unnecessary memory copies</li>
                        <li><strong>mmap()</strong> - Created memory-mapped buffers for efficient I/O</li>
                        <li><strong>sendfile()</strong> - Direct file-to-socket transfers</li>
                        <li><strong>splice()</strong> - Pipe-based zero-copy operations</li>
                        <li><strong>Performance Measurement</strong> - Quantified improvements</li>
                    </ul>
                </div>

                <div class="performance-summary">
                    <h3>ðŸ“Š Performance Gains</h3>
                    <div class="gain-metrics">
                        <div class="metric">
                            <div class="metric-value">50%+</div>
                            <div class="metric-label">CPU Reduction</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">2x</div>
                            <div class="metric-label">Throughput Increase</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">0</div>
                            <div class="metric-label">Memory Copies</div>
                        </div>
                    </div>
                </div>

                <div class="knowledge-check">
                    <h4>ðŸ§  Final Knowledge Check</h4>
                    <ul>
                        <li>
                            <input type="checkbox" id="final1"> 
                            <label for="final1">I can explain the difference between traditional and zero-copy I/O</label>
                        </li>
                        <li>
                            <input type="checkbox" id="final2"> 
                            <label for="final2">I implemented and tested mmap(), sendfile(), and splice()</label>
                        </li>
                        <li>
                            <input type="checkbox" id="final3"> 
                            <label for="final3">I measured significant performance improvements</label>
                        </li>
                        <li>
                            <input type="checkbox" id="final4"> 
                            <label for="final4">I understand when to use each zero-copy technique</label>
                        </li>
                    </ul>
                </div>

                <div class="next-steps">
                    <h3>ðŸš€ Next Steps</h3>
                    <p>
                        In Chapter 3, we'll combine zero-copy operations with epoll-based async I/O
                        to handle thousands of concurrent connections efficiently.
                    </p>
                    <p>
                        <strong>Preview:</strong> Single-threaded server handling 10,000+ concurrent connections
                        with sub-millisecond latency.
                    </p>
                </div>
            </section>

            <nav class="chapter-nav">
                <a href="../chapter1/" class="nav-btn nav-prev">
                    Previous: Linux Raw Sockets
                </a>
                <a href="../chapter3/" class="nav-btn nav-next">
                    Next: Epoll Async I/O
                </a>
            </nav>
        </main>
    </div>
</body>
</html>